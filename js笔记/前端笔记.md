# HTML

## DOM (文档对象模型)

当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。

## 自定义html标签

要创建自定义HTML标签，我们需要使用HTML5的新增功能——自定义元素。

方法一：

1. 在HTML文档的`<head>`或`<body>`部分引入一个JavaScript文件，该文件将负责定义自定义元素的行为和样式。
2. 在JavaScript文件中，使用`window.customElements.define`方法来定义自定义元素。该方法接受两个参数：自定义元素的名称和定义该元素的类。
3. "自定义元素的名字必须包含一个破折号（`-`）所以`<x-tags>`、`<my-element>`和`<my-awesome-app>`都是正确的名字，而`<tabs>`和`<foo_bar>`是不正确的。这样的限制使得 HTML 解析器可以分辨那些是标准元素，哪些是自定义元素。"

```html
<!--index.html-->
<!DOCTYPE html>
<html>
  <head>
    <title>自定义HTML标签示例</title>
    <script src="my-element.js"></script>
  </head>
  <body>
    <my-element></my-element>
  </body>
</html>
```

```js
// my-element.js
class MyElement extends HTMLElement {
  constructor() {
    super();
    // 添加元素的内容或样式等
       let template = document.getElementById("my-paragraph");
      let templateContent = template.content;

      const shadowRoot = this.attachShadow({ mode: "open" });
      shadowRoot.appendChild(templateContent.cloneNode(true));
  }
}
window.customElements.define('my-element', MyElement);
```

注意，一旦名字之中使用了破折号，自定义元素就不是HTMLUnknownElement的实例了。

方法二：

浏览器提供了一个`HTMLUnknownElement`对象，所有自定义元素都是该对象的实例。

```js
var tabs = document.createElement('tabs');

tabs instanceof HTMLUnknownElement // true
tabs instanceof HTMLElement // true
```

上面代码中，`tabs`是一个自定义元素，同时继承了`HTMLUnknownElement`和`HTMLElement`接口。

参考：[HTML 自定义元素教程 - 阮一峰的网络日志 (ruanyifeng.com)](https://ruanyifeng.com/blog/2017/06/custom-elements.html)



事实上对于未定义的标签，html也是当作普通元素解析（经测试，就是当成文本，原样输出标签之间的东西）



## template标签

`<template>`元素，中文称为模板元素，顾名思义，它最大的作用是将元素标签内的所有元素作为**模板**储存在HTML文件中。并且，浏览器会**忽略**模板元素的内容，**仅**检查它内部语法的有效性。我们可以在合适的时候，利用JavasScript来访问、使用模板元素来创建内容。

该部分是在运行时不显示的，可以理解为函数没有调用

利用js将该部分内容添加进页面

```html
<template>
  <div class="myClass">I like: </div>
</template>

<script>
let myArr = ["Audi", "BMW", "Ford", "Honda", "Jaguar", "Nissan"];
function showContent() {
  let temp, item, a, i;
  temp = document.getElementsByTagName("template")[0];
  item = temp.content.querySelector("div");
  for (i = 0; i < myArr.length; i++) {
    a = document.importNode(item, true);
    a.textContent += myArr[i];
    document.body.appendChild(a);//向页面添加模板内的元素
  }
}
</script>
```

### 自定义组件

```js
customElements.define(//自定义标签
  "element-details",//标签名
  class extends HTMLElement {
    constructor() {
      super();
      var template = document.getElementById(
        "element-details-template",//标签关联的网页代码，此处为模板
      ).content;
      const shadowRoot = this.attachShadow({ mode: "open" }).appendChild(
        template.cloneNode(true),
      );
    }
  },
);

```

```html
<template id="element-details-template">//标签所关联的模板
  <style>
    details {
      font-family: "Open Sans Light", Helvetica, Arial;
    }
    h4 span {
      color: white;
    }
    .attributes p {
      margin-left: 16px;
      font-style: italic;
    }
  </style>
  <details>
    <summary>
      <span>
        <code class="name"
          >&lt;<slot name="element-name">NEED NAME</slot>&gt;</code
        >
        <i class="desc"><slot name="description">NEED DESCRIPTION</slot></i>
      </span>
    </summary>
    <div class="attributes">
      <h4><span>Attributes</span></h4>
      <slot name="attributes"><p>None</p></slot>
    </div>
  </details>
  <hr />
</template>

<!--使用自定义标签，由于原内容包含slot标签，因此此处设置slot属性即可对应替换-->
<element-details>
  <span slot="element-name">插槽</span>
  <span slot="description"
    >用户可以用自己编写的标记填充至 web 组件中的占位符，从而达到组合不同 DOM
    树的效果。</span
  >
  <dl slot="attributes">
    <dt>名称</dt>
    <dd>插槽的名称</dd>
  </dl>
</element-details>

<element-details>
  <span slot="element-name">模板</span>
  <span slot="description"
    >一种用于保存客户端内容的机制，此类内容不会在页面加载时呈现，但随后可能在运行时使用
    JavaScript 实例化。</span
  >
</element-details>
```

此处使用上面定义的标签

参考：[使用模板和插槽 - Web API | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_components/Using_templates_and_slots)



## #id

上述用法表示位置

即id所在的位置

对于slot而言name也可以使用#表示位置

## slot标签和属性

### 标签：

插槽由其 `name` 属性标识，并且允许你在模板中定义占位符，当在标记中使用该元素时，该占位符可以填充所需的任何 HTML 标记片段。

```html
<template>
    <slot>
      <p>插槽后备的内容</p>  <!--若浏览器不支持slot则会显示后备内容-->
    </slot>
</template>
```

`name`属性来表示插槽的名字，不传为默认插槽

插槽类型：

匿名插槽（未设置name）

具名插槽（设置了name）

[深入理解vue中的slot与slot-scope ， 弄清楚 slot slots 的区别，scoped的含义_slot scoped-CSDN博客](https://blog.csdn.net/acoolgiser/article/details/106171618)



### 属性：

```html
<zxx-alert open>
    <p slot="alert">插槽执行成功！</p>
</zxx-alert>
```

设置slot属性与slot标签进行匹配

# CSS

## 定义变量

声明一个自定义属性，属性名需要以两个减号（`--`）开始，属性值则可以是任何有效的 CSS 值。和其他属性一样，自定义属性也是写在规则集之内的，如下：

```css
element {
  --main-bg-color: brown;
}

```

如前所述，使用一个局部变量时用 [`var()`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/var) 函数包裹以表示一个合法的属性值：

```css
element {
  background-color: var(--main-bg-color);
}

```

应用举例：

页面

```html
<p v-for="(item, index) in dataList" :key="index" :style="{'--color': item.color}" >{{item.name}}</p>
```

css：

```css
p{
	color: var(--color);
}
```

js

```js
data() {
	return {
		dataList: [
			{name: '红色', color: 'red'},
			{name: '蓝色', color: 'blue'},
			{name: '绿色', color: 'green'}
		]
	}
}
```

结果：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/2b1e964d787df51d1428e0271e59c1cb.png)

参考：[【SCSS变量】$ | & | var | @for | @include | @function | @each 等常用方法使用_scss var-CSDN博客](https://blog.csdn.net/sunshineTing2/article/details/132474857)

注意：<font color='red'>**CSS变量名称区分大小写**</font>



### 变量运算

**属性值不能直接进行数学运算，需要借助calc()函数**

```css
--font-size:12px *2; /**错误的方式**/
--font-size:calc(12px*2);/**正确的方式**/
```

### CSS变量的相互传递特性

```css
body {
  --green: #4CAF50;   
  --backgroundColor: var(--green);
}

body {
  --columns: 4;
  --margins: calc(24px / var(--columns));/*****这个变量的值可以使用其他变量进行运算*****/
}
```



### 使用js变量（vue）

通过vbind即可绑定js脚本中的变量，

1.但是得注意，使用js变量来设置样式时，带单位的样式可能会出错(和预期不一致)

因为：CSS变量的空格尾随特性

例如：

```css
body {
  --size: 20;   
  font-size: var(--size)px; /**等价于 font-size: 20 px ***/
}
```

此时`<body>`的`font-size`大小是多少？

如果你以为是`20px`就太天真了，实际上，此处`font-size:var(--size)px`等同于`font-size:20 px`，注意，`20`后面有个**空格**，所以，这里的`font-size`使用的是`<body>`元素默认的大小。

使用稳妥的做法：

```css
body {
  --size: 20px;   
  font-size: var(--size);
}
或者
body {
  --size: 20;   
  font-size: calc(var(--size) * 1px);
}
```

2.对于CSS变量，只要语法是正确的，就算变量里面的值是个乱七八糟的东西，也是会作为正常的声明解析

```
body {
  --color: 20px;
  background-color: #369;
  background-color: var(--color, #cd0000);
}
```



## position

- **定位元素**（positioned element）是其[计算后](https://developer.mozilla.org/zh-CN/docs/Web/CSS/computed_value)位置属性为 `relative`, `absolute`, `fixed` 或 `sticky` 的一个元素（换句话说，除`static`以外的任何东西）。
- **相对定位元素**（relatively positioned element）是[计算后](https://developer.mozilla.org/zh-CN/docs/Web/CSS/computed_value)位置属性为 `relative`的元素。
- **绝对定位元素**（absolutely positioned element）是[计算后](https://developer.mozilla.org/zh-CN/docs/Web/CSS/computed_value)位置属性为 `absolute` 或 `fixed` 的元素。
- **粘性定位元素**（stickily positioned element）是[计算后](https://developer.mozilla.org/zh-CN/docs/Web/CSS/computed_value)位置属性为 `sticky` 的元素。

### 设置子控件的位置只相对于父控件

在CSS中，控件（或更一般地说，元素）的位置通常是相对于其最近的已定位（即，其`position`属性不是`static`的）祖先元素来设置的。

如果你想要一个元素仅相对于其父元素定位，你应该将父元素的`position`设置为`relative`（因为`relative`定位不会脱离文档流，只是相对于其正常位置进行偏移），然后将子元素的`position`设置为`absolute`。这样，子元素就会相对于其父元素进行定位。



## margin和padding

margin其实就是外边距



padding是内边距



需要注意的情况：

1.设置margin时，存在margin合并的情况，比如兄弟元素之间设置了上边距和下边距，那么两元素的间距会变成其中最大的margin值，而不是margin元素之和。

2.



## transition

语法：transition: property duration timing-function delay

1、transition是个复合属性，它包括以下几个子属性

        transition-property ：规定设置过渡效果的css属性名称
    
        transition-duration ：规定完成过渡效果需要多少秒或毫秒
    
        transition-timing-function ：指定过渡函数，规定速度效果的速度曲线
    
        transition-delay ：指定开始出现的延迟时间

2、默认值为：all 0 ease 0

3、改变多个css属性的过渡效果时：

```css
a{ transition: background 0.8s ease-in 0.3s,color 0.6s ease-out 0.3s;}
```

例如我要对位置变化做过度操作

```css
transition: transform 0.5s linear; /* 平滑过渡效果 */
transform: translateX(0px);

//transition选中了transform属性进行linear形式的过度，你就可以看到元素平滑的移动
```



参考：[CSS Transition（过渡效果）详解-CSDN博客](https://blog.csdn.net/qq_32594913/article/details/135915376)

https://blog.csdn.net/debugtoday/article/details/123069480



## animation

语法：

```css
animation: name duration timing-function delay iteration-count direction fill-mode play-state;
//例如：
animation:myAnim 1s linear 1s infinite alternate both running;

```

要配合关键帧使用

keyframes：定义动画规则，关键帧。

| 值                 | 说明                                |
| ------------------ | ----------------------------------- |
| animationname      | 必需的。定义animation的名称。       |
| keyframes-selector | 必需的。动画持续时间的百分比。      |
| css-styles         | 必需的。一个或多个合法的CSS样式属性 |

```css
@keyframes myAnim{
  from { background: #f00; }
  50% { background: #0f0; }
  to { background: yellowgreen; }
}

```

如果省略某个状态，浏览器会自动推算中间状态。但是，为了获得最佳的浏览器支持，应该始终定义0％和100％的选择器。

定义动画时，必须定义动画的名称和动画的持续时间。如果省略持续时间，动画将无法运行，因为默认值是0。



## display设置布局

### flex布局(弹性盒布局)

```
flex:1
```

等价于如下设置

```css
flex-grow : 1; // 这意味着div将以与窗口大小相同的比例增长
flex-shrink : 1; // 这意味着div将以与窗口大小相同的比例缩小
flex-basis : 0; // 这意味着div没有这样的起始值，并且将根据可用的屏幕大小占用屏幕。例如： - 如果包装器中有3个div，则每个div将占用33％。
```

`flex-grow：`

属性用于设置或检索弹性盒子的扩展比率（即 `放大比例`）

- 默认值为 `0` ， 当项目有剩余空间时，也默认不会放大
- 若设置值为 `1` ， 则代表当项目有剩余的空间时，会自动放大占有比例
- 若设置值为 `n`， 则代表放大的比例是 `flex-grow` 为 1 的 `n`倍

`flex-basis：`

属性用于设置或检索弹性盒伸缩基准值（即 `项目占据的主轴的空间`）

- 默认值, `auto`， 长度等于灵活项目的长度
- 如果该项目未指定长度，则长度将根据内容决定
- 设置后，将根据设定的值占据固定的空间长度

例如：

1. `flex: 0 0 10%`：默认元素有剩余空间也不放大，空间不足时也不能缩小，长度占据当前项目总空间的`10%`



![img](https://i-blog.csdnimg.cn/blog_migrate/4ecdc7e3ef3da58bf4e9d6e46586aa2f.png)

如上图所示，使用水平流式布局设置flex都为1使得每一块长度一样，并占满全部的空间



```vue
<view class="content">
		<view class="view1">首页</view>
		<view class="view1">新闻</view>
		<view class="view1">体育</view>
	</view>
```

```css
.content {
		display: flex;
	}
 
.view1 {
    flex: 1;
    text-align: center;
    line-height: 50px;
    background-color: #007AFF;
}
```

其他操作

1.设置元素超过宽度自动换行

i.给父元素加上`flex-flow:row wrap` 之后就可以让子元素保持设置的宽度并且换行



![img](https://i-blog.csdnimg.cn/blog_migrate/1c8f2e7553ab8071f3670196790c4a84.png)

ii.flex-wrap

```css
.container {
  flex-wrap: nowrap | wrap | wrap-reverse;
}
```

- `nowrap`（默认值）: 不折行，所有的子元素会排在一行。
- `wrap`: 折行，子元素会从上到下根据需求折成多行。
- `wrap-reverse`: 折行，子元素会从下到上根据需求折成多行。

2.设置布局方向

`flex-direction`

![img](https://xiaonenglife.oss-cn-hangzhou.aliyuncs.com/static/pic/2022/09/20220916001346_flex-direction.svg)

```
.container {
  flex-direction: row | row-reverse | column | column-reverse;
}
```

- `row`（默认）：在LTR排版方式下从左到右; RTL从右到左
- `row-reverse`：LTR 从右到左; RTL 从左到右
- `column`：从上到下
- `column-reverse`：从下到上



参考：[我的Vue之旅、01 深入Flexbox布局完全指南 - 小能日记 - 博客园 (cnblogs.com)](https://www.cnblogs.com/linxiaoxu/p/16699507.html)



### grid布局



### block布局



## 居中显示设置

### 文本居中

```css
text-align：center;
```



### 内容居中

```css
display: flex;
    justify-content: center; /* 水平居中 */
    align-items: center; /* 垂直居中 */
```



## 颜色渐变

径向渐变



线性渐变

**`linear-gradient()`** [CSS](https://developer.mozilla.org/zh-CN/docs/Web/CSS) [函数](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Functions)创建一个由两种或多种颜色沿一条直线进行线性过渡的图像，其结果是 [``](https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient) 数据类型的对象，此对象是一种特殊的 [``](https://developer.mozilla.org/zh-CN/docs/Web/CSS/image) 数据类型。

```css
/* 渐变轴为 45 度，从蓝色渐变到红色 */
linear-gradient(45deg, blue, red);

/* 从右下到左上、从蓝色渐变到红色 */
linear-gradient(to left top, blue, red);

/* 色标：从下到上，从蓝色开始渐变，到高度 40% 位置是绿色渐变开始，最后以红色结束 */
linear-gradient(0deg, blue, green 40%, red);

/* 颜色提示：从左到右的渐变，由红色开始，沿着渐变长度到 10% 的位置，然后在剩余的 90% 长度中变成蓝色 */
linear-gradient(.25turn, red, 10%, blue);

/* 多位置色标：45% 倾斜的渐变，左下半部分为红色，右下半部分为蓝色，中间有一条硬线，在这里渐变由红色转变为蓝色 */
linear-gradient(45deg, red 0 50%, blue 50% 100%);

```

## 长宽相等（正方形）

1.js设置

2.padding

在css里面，padding-top,padding-bottom,margin-top,margin-bottom取值为百分比的时候，参照的是父元素的宽度。

比如：父元素宽度是100px, 子元素padding-top:50%，那么padding-top的实际值就是100*50%=50px

这个小小的知识点，其实有很大的用处，应用也很广泛，就是进行提前占位，避免资源加载时候的闪烁，还可以让高度自适应。

[利用padding-top/padding-bottom百分比，进行占位和高度自适应_padding-top 百分比-CSDN博客](https://blog.csdn.net/literarygirl/article/details/137118499#:~:text=在css里面，padding-top%2Cpadding-bottom%2Cmargin-top%2Cmargin-bottom取值为 百分比 的时候，参照的是父元素的宽度。 比如：父 元素宽度,是100px%2C 子元素padding-top%3A50%，那么padding-top的实际值就是100*50%%3D50px 这个小小的知识点，其实有很大的用处，应用也很广泛，就是进行提前占位，避免资源加载时候的闪烁，还可以让高度自适应。 举例： 一般来说，想要自适应屏幕大小，我们设置元素的宽度自适应是完全没有问题的，比如希望一行显示5个元素，那么我们设置每个元素width%3A20%就可以了（box-sizing需要为border-box）。)

例如：

```vue
 <ul>
        <li class="item placeholder"><img class="img"
            src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1532110043386&di=dc7277a3b566e40a9d98d736f1613dd2&imgtype=0&src=http%3A%2F%2Fpic.qqtn.com%2Fup%2F2016-5%2F201605301928431736188.png">
        </li>
        <li class="item placeholder"><img class="img"
            src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1532110043386&di=dc7277a3b566e40a9d98d736f1613dd2&imgtype=0&src=http%3A%2F%2Fpic.qqtn.com%2Fup%2F2016-5%2F201605301928431736188.png">
        </li>
    </ul>        

```

```css
item {
    width: 20%;
}

.placeholder {
    padding-top: 26%;
}

```

通过css可以将每个li的宽高比设置为1:1.3（20：26）

# SCSS

调用JS变量

## 选择器

参考：[CSS、Sass、Scss，以及sass和scss的区别 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000019573996)



```css
在嵌套的代码块内，可以使用&引用父元素。比如a:hover伪类，可以写成
a {
    &:hover { color: #ffb3ff; } }
```

scss同时提供了特殊的**父选择器标识符 &** ，通过它可以构造出更高效的嵌套。

## 定义变量

### 变量声明（`$`）和使用

```css
// 用`$`声明变量
$color: red;

// 直接使用变量
span{ color: $color; }
p{ background: $color; }
```

### 作用域

定义在全局，则是全局变量，全局可用。定义在选择器内部，则是本地变量。本地变量只在嵌套的选择内部可用。



在同一个作用域定义同一个变量，变量被覆盖。术语叫重载。比如：

```css
$primary:red;
.link{
  color:$primary
}
$primary:green;
.other-link{
  color:$primary;
}

//编译后：
.link{
  color:red;
}
.other-link{
  color:green;
}

相当于后面的被覆盖了
```



### 变量的运算

支持数字的加减乘除、取整等运算 (`+, -, *, /, %`)

以下三种情况 `/` 将被视为除法运算符号：

- 如果值，或值的一部分，是变量或者函数的返回值
- 如果值被圆括号包裹
- 如果值是算数表达式的一部分

```css
p {
  font: 10px/8px;             // Plain CSS, no division
  $width: 1000px;
  width: $width/2;            // Uses a variable, does division
  width: round(1.5)/2;        // Uses a function, does division
  height: (500px/2);          // Uses parentheses, does division
  margin-left: 5px + 8px/2px; // Uses +, does division
}
```



### 使用js变量：

使用vbind

[Vue2/Vue3中在css中使用js的变量（less、scss也适用）前言 很多情况我们需要主题搭配，亦或是统一便捷的 - 掘金 (juejin.cn)](https://juejin.cn/post/7005744294799605773)



## 循环



## 继承

使用 （@extend）继承 公共类（元素名、.class）
//通过选择器继承继承样式

```css
.error {
  border: 1px solid red;
  background-color: #fdd;
}

.seriousError {
  @extend .error; // 继承
  border-width: 3px;
}
```



# JS

HTML 中的 Javascript 脚本代码必须位于 <script> 与 </script> 标签之间。

或者通过外部脚本加载，在 <script> 标签的 "src" 属性中设置该 .js 文件：

## 语法

### 加不加分号

在编写JavaScript程序时，一般会有两种编码习惯，**加分号** 和 **不加分号** ：

- **加分号：** 许多程序员使用分号来明确标记语句的结束，即使在并不完全需要分号的时候也是如此；
- **不加分号：** 另一种风格是，在任何可以省略分号的地方，都将其省略，只有在不得不用的时候才使用分号。一般js分行后就表示上一条语句结束了。

总结：**可加可不加**，为了增加可读性，**最好加上分号**



必须加分号的场景：

1.如果多条语句写在同一行，则必须要加分号：

```js
let x , y
x = 10  y = 30  //不合法
console.log(x+y) //SyntaxError: Unexpected identifier
```

2.通俗来讲，如果一条语句以 "(" ,"[" , "/" , "+" , "-" 开始，它们极有可能和前面一条语句一起解析。如果前一条语句无法和后一条语句合并解析，JavaScript才会在第一条语句后插入分号

示例：

```js
let m = n + f
(b+c).toString()
//这种情况js会被解析成如下语句，即合并解析了，完全违背原意
let m = n + f(a+b).toString();
```

3.涉及 return 、break、continue 时，如果这三个关键字后紧跟换行，则该关键字后一定会插入分号；

```js
return
true
//会被解析为如下语句，全都默认添了分号，违背原意
return;
true;
```

### 变量相关

#### 声明方式以及区别

使用let/var声明变量，或者不声明直接赋值

三种方式的区别：

1.使用var/let声明的是具有不可删除属性的**变量**，使用直接赋值方式产生的是**全局对象属性**

 var num = 1 跟 num = 1，前者是变量声明，带不可删除属性，因此无法被删除；

后者为全局变量的一个**属性**（window对象的一个属性），因此可以从全局变量中删除。

（可以理解为python里面类的动态的成员/属性，直接在某个方法中开辟了一个新的成员，当那个方法执行后，类便有了这个成员，没有执行便没有这个成员）示例：

```python
class Person():
	def __init__(self,name): 
		self.name = name 
    def setAge():
        self.age=10#在这个方法内动态产生了一个age属性
```

把js所有代码理解为在window这个全局对象的方法体内执行就很好对应了，执行num=1就相当于动态产生了一个属性，这个属性在window的各方法内就都能使用了，也就类似于一个全局变量。

参考：[js 变量声明 （var使用与不使用的区别） - 范仁义 - 博客园 (cnblogs.com)](https://www.cnblogs.com/Renyi-Fan/p/10223112.html)

[在 Javascript 中 声明时用 var 与不用 var 的区别 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/javascript-var-and-without-var.html)



2.var和直接赋值

i.**在<font color=red>函数/方法内部</font>时**：

有var定义的变量，会将变量的范围限定在**var所在的范围**，相当于**局部变量**。

没有var定义的变量，会成为**全局变量**。

```js
//注意，以下写法为函数立即执行
//var
!function(){
        var counter=1;
        counter ++;
        console.log(counter);   // 输出：2
        counter ++;
}();
console.log(counter);  // 输出： ReferenceError: counter is not defined

//无声明，相当于全局变量
!function(){
        counter=1;
        counter ++;

        console.log(counter);  // 输出：2
        counter ++;
}();
console.log(counter);  // 输出：3
```

ii.在全局作用域使用，都相当于全局变量



3.let和var：

共同点： 声明后未赋值，表现相同

```js
(function() {
      var varTest;
      let letTest;
      console.log(varTest); //输出undefined
      console.log(letTest); //输出undefined
    }());
```

区别：

i.先使用后声明，var变量可输出，let变量报错（这种情况叫**变量提升**，就是先使用后声明）

ii.**重复声明**同一个变量，var可以正常使用，let报错

iii.作用范围不同，var没有块级作用域，用let声明的变量支持块级作用域

（块级作用域则是一个大括号就是一个块级作用域，该变量只能在块级作用域里使用，否则就会报错。）

```js
//i
console.log(varTest); //输出undefined(注意要注释掉下面一行才能运i行)
console.log(letTest); //IE报错：ReferenceError: letTest is not defined   
var varTest = 'test var OK.';
let letTest = 'test let OK.';
//ii
var varTest = 'test var OK.';
let letTest = 'test let OK.';
var varTest = 'varTest changed.';
let letTest = 'letTest changed.'; //直接报错：SyntaxError: 
//iii
if (true) { //此处按理来说在if内定义的变量在外面是不起作用的，但是var可以
  var a = 1; 
}
console.log(a); // 1

(function() {
  var varTest = 'test var OK.';
  let letTest = 'test let OK.';
  {
    var varTest = 'varTest changed.';
    let letTest = 'letTest changed.';
    console.log(varTest);   // 输出varTest changed.
    console.log(letTest);   // 输出letTest changed.
  }
  console.log(varTest); //输出"varTest changed."，内部"{}"中声明的varTest变量覆盖外部的letTest声明
  console.log(letTest); //输出"test let OK."，内部"{}"中声明的letTest和外部的letTest不是同一个变量
}());
```

下面这个案例更直观，使用var，则每次点击按钮输出相同的数字

比如有六个按钮就每次输出6。

因为i是不受区域限制相当于全局的。在此过程中i从0加到6，按钮读取到的i是最后的实际值，而不是执行过程中那个0 1 2 3 4 ....

所以每次按钮输出的i实际上是最后执行完之后的那个值6

这个代码把var i改成**let** i就能够使用过程中的值。

换个角度理解 使用var，实际上事件函数是console.log(i);

而使用let，实际上事件函数是console.log(1 2 3 ...);

```js
var oLi =document.getElementById('test').getElementsByTagName('li');
for(var i = 0; i < oLi.length; i++) {            
    oLi[i].onclick =function(event) {
        console.log(i);
    }
}
```



#### 命名规则

- 只能用下划线、字母、数字、$组成，且数字不能开头
- 字母严格**区分大小写**，如 Age 和 age 是不同的变量



### 函数

注意：函数可被看作对象，具有属性与方法

```js
//函数格式
function functionName(parameters) {
    执行的代码
}
//示例
function myFunction(a, b) {
    return a * b;
}
```

#### 特殊用法：

JavaScript 函数可定义为一个表达式。

```js
var x = function (a, b) {return a * b};//类似于lamda表达式
var z = x(4, 3);
```

#### 立即执行写法：

```js
!function () { /* ... */ }();
~function () { /* ... */ }();
-function () { /* ... */ }();
+function () { /* ... */ }();
void function () { /* ... */ }();
(function (){/*...*/}());
(function (){/*...*/})();
```

①函数后的();表示要执行这个函数；

②而();要求前面必须是一个表达式。（最后有js表达式的定义）。

③所以“!”的作用是将function(){}函数体转为一个函数表达式。

总之函数后面接了一个（）的基本都是要函数**立即执行**

```js
!function() {
    var count=1;
    console.log(count+1);
}();
//立马输出
2
```

参考：[JS中!function(){}()的理解_js !function-CSDN博客](https://blog.csdn.net/qq_23853743/article/details/106757787)

#### 内嵌函数

函数内部定义的函数



#### 闭包

简单来说，就是利用嵌套函数，调用函数内的局部变量，实现类似于类成员的效果

```js
var add = (function () {
    var counter = 0;
    return function () {return counter += 1;}
})();//该写法为立即调用，执行counter=0，并将匿名函数给了add
add();//每次调用add会使counter+1
add();
add();
// 计数器为 3
```

#### 传参：

**缺省值**：

1.参数缺省值可以引用其他缺省参数

2.缺省值从右到左写，左边有默认值而右边没有是不行的

```js
function bar(x = 1, y = x, z = x + y) {
    return x + y + z;
}
 
console.log(bar()); // 4

```

**传入字典类型参数**：

```js
//1.预先设定好参数
function test(params={}){
    const{
        p1=null;
        p2=null;
    }=params;
    //后续就可以使用解包后的数据p1，p2
    console.log(p1)
}

test({p1=1});//此处应该按照const定义的参数来赋值

//2.或者for循环遍历
setValues( values ) {
		if ( values === undefined ) return;
		for ( const key in values ) {
			const newValue = values[ key ];
			if ( newValue === undefined ) {
				...
			}
			...
        }
}
```

在



**解构参数**

```js
function greet({ name }) {
  return `Hello, ${name}!`;
}

const person = { name: '前端小智' };
greet(person); // => 'Hello, 前端小智!'


function greeFirstPerson([{ name }]) {
  return `Hello, ${name}!`;
}

const persons = [{ name: '王小智' }, { name: '王大治'}];
greeFirstPerson(persons); // => 'Hello, 王小智!'
```

**arguments 对象**

所有函数（非箭头）中都有一个名为 `arguments` 的特殊的**类数组对象**（不是 `Array` 的实例），它保存着所有实参的副本，我们可以通过它按照数组的索引访问方式获取所有实参的值，也可以访问它的 `arguments.length` 属性来确定函数实际调用时传入的参数个数。

```js
function foo() {
	console.log(arguments[0]);
    console.log(arguments[1]);
}

foo(10, 20); // 依次输出 10、20 

```

参考

[javascript - 掌握JS函数中的几种参数形式（函数基础） - 终身学习者 - SegmentFault 思否](https://segmentfault.com/a/1190000020436141)



### js字典

判断长度

```js
let obj={
};
 
if(Object.keys(obj).length>0){
    console.log('obj 不为空')
}else{
    console.log('obj为空')
}

dic.count()
```

遍历：

```js
    for(var key in dic){ // 输出字典元素，如果字典的key是数字，输出时会自动按序输出
        console.log(key + ' : ' + dic[key]);
    }
```

删除/添加元素：

```js
delete dic['one'];    // 删除元素(方法一)
delete dic['six'];
delete dic.three;   // 删除元素(方法二)   
delete dic.four;
for(var key in dic){ 
    console.log(key + ' : ' + dic[key]);
}

dic['9']='helo'             // 添加字典的元素( key:value)
```

全操作封装：

```java
    function add(key, value){   // 添加字典的键值(key:value)
        this.dataStore[key] = value;
    }
    function show(){            //显示字典中的键值(key:value)
        for(var key in this.dataStore){
            console.log(key + " : " + this.dataStore[key]);
        }
    }
    function find(key){         // 根据键(key)查找对应的值(value),返回值value
        return this.dataStore[key];
    }
    function remove(key){       // 根据键(key)删除对应的值(value)
        delete this.dataStore[key];
    }
    function count(){           // 计算字典中的元素个数
        var n = 0;
        for(var key in Object.keys(this.dataStore)){
            ++n;
        }
        return n;
    }
    function kSort(){           // 字典按值(value)排序,并输出排序后的结果
        var dic = this.dataStore;
        var res = Object.keys(dic).sort();
        for(var key in res ){
            console.log(res[key] + " : " + dic[res[key]]);
        }
    }
    function vSort(){           // 字典按值(value)排序,并输出排序后的结果
        var dic = this.dataStore;
        var res = Object.keys(dic).sort(function(a,b){ 
            return dic[a]-dic[b]; 
        });
        for(var key in res ){
            console.log(res[key] + " : " + dic[res[key]]);
        }
    }
    function clear(){           // 清空字典内容
        for(var key in this.dataStore){
            delete this.dataStore[key];
        }
    }
    function Dictionary(){              
        this.dataStore = new Array(); // 定义一个数组，保存字典元素
        this.add = add;               // 添加字典内容(key:value)
        this.show = show;             // 显示字典中的键值
        this.find = find;             // 根据键(key)查找并返回对应的值(value)
        this.remove = remove;         // 删掉相对应的键值
        this.count = count;           // 计算字典中的元素的个数
        this.kSort = kSort;           // 按键(key)排序
        this.vSort = vSort;           // 按值(value)排序
        this.clear = clear;           // 清空字典内容
    }

    var dic = new Dictionary();       // 构造字典类

```



### 导入和导出

JavaScript 中的模块使用 `import` 和 `export` 关键字:

- `import`: 用于读取从另一个模块导出的代码。
- `export`: 用于向其他模块提供代码。

```js
//functions.js
export function sum(x, y) {
  return x + y;
}
export function difference(x, y) {
  return x - y;
}
export function product(x, y) {
  return x * y;
}
export function quotient(x, y) {
  return x / y;
}
//script.js
import { sum, difference, product, quotient } from "./functions.js";
//通过在花括号来导入单个函数
const x = 10;
const y = 5;

document.getElementById("x").textContent = x;
document.getElementById("y").textContent = y;

document.getElementById("addition").textContent = sum(x, y);
document.getElementById("subtraction").textContent = difference(x, y);
document.getElementById("multiplication").textContent = product(x, y);
document.getElementById("division").textContent = quotient(x, y);
```

**注意**：`import` 必须始终位于文件的顶部。在这个例子中并且还必须使用相对路径（本示例为 `./`）。

通过在花括号中命名单个函数来导入它们，此外允许别名（类似于python），防止名字冲突。

```js
import { sum as add, difference as subtract } from "./functions.js";
add(1, 2); // 3
```

通过as设置模块别名

若想导入全部，使用*****号：

```javascript
import * as mathFunctions from "./functions.js";
mathFunctions.sum(1, 2); // 3
mathFunctions.difference(10, 3); // 7
```

参考：[JavaScript 中模块的导入和导出——最最最简明教程 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000038457788)



为了确保此代码作为**模块**而不是**常规脚本**加载，请在 `index.html` 中的 `script` 标签中添加 `type ="module"`。任何使用 `import` 或 `export` 的代码都必须使用这个属性：

```js
...
<script type="module" src="functions.js"></script>
<script type="module" src="script.js"></script>
```

模块与常规脚本的区别：

- 模块不会向全局（`window`）作用域添加任何内容。
- 模块始终处于[严格模式](https://link.segmentfault.com/?enc=kULrFsN%2FwCg2%2B1TpzdgvYQ%3D%3D.a1bWWa02qIZ7Oi5n%2BDXTDsAFmSRPfG9MzLqpkigPeosw%2F7kwCIBetgsk3Rrkl8nZMQkpgIEMCWFE%2Bl2fLfDT3fRsxEF4WUaTZh6jHulWtcI%3D)。
- 在同一文件中引用同一模块多次将无效，因为模块**只会被执行一次**。
- 模块需要运行在服务器环境。

#### 导入：

具名导入：`import { export1, export2 } from "module-name";`
默认导入：`import defaultExport from "module-name";`
命名空间导入：`import * as name from "module-name";`
副作用导入：`import "module-name";`

```js
//具名
import { myExport } from "/modules/my-module.js";
import { reallyReallyLongModuleExportName as shortName } from "/modules/my-module.js";
//默认导入
import myDefault from "/modules/my-module.js";
//由于默认导出没有明确指定名称，因此你可以为标识符指定任何你喜欢的名称。
//也可以在使用命名空间导入或具名导入时指定默认导入。在这种情况下，必须首先声明默认导入。例如：
import myDefault, * as myModule from "/modules/my-module.js";

```

## 遍历：

for...in...遍历List/map

```js
//遍历map
for(var key in map_demo){
        console.info(key+":"+map_demo[key]);
}
//遍历List
for(var index in list2){
        console.info(index+":"+list2[index]);

}
```

数组

for…in…

输出的 key 是数组索引），如果遍历的是对象，输出的则是对象的属性名

不推荐

for…of…（ES6）

```js
var arr = ['我', '是', '谁', '我', '在', '哪']
for(var key of arr) {
    console.log(key)
}
// 我 是 谁 我 在 哪
```

普通for循环

```js
var arr = [1, 2, 3, 4, 5, 6]
for(var i = 0; i < arr.length; i++) {
	console.log(arr[i])
}
```

### forEach（也叫作增强for循环）

```js
list2.forEach(function (element, index, array) {
        console.info(element); //当前元素的值
        console.info(index);   //当前下标
        console.info(array);  //数组本身 

});

```

数组里的元素个数有几个，该方法里的回调就会执行几次



## js类

### 构造函数

`constructor()`是类的构造函数

```javascript
class Runoob {
  constructor(name, url) {
    this.name = name;
    this.url = url;
  }
}

let site = new Runoob("菜鸟教程",  "https://www.runoob.com");
```

### 类表达式

```javascript
const MyClass = class [className] [extends otherClassName] {
  // class body
}
```

类表达式和类声明之间存在一些差异，但是：

1. 类表达式可以省略类名（“绑定标识符”），这在类声明中是不可能的。
2. 类表达式允许你**重新定义（重新声明）类**而不会抛出 SyntaxError。类声明不是这种情况。

constructor 方法是可选的。使用类表达式生成的类将始终响应 typeof 值为 "function"。

```js
"use strict";
let Foo = class {}; // constructor property is optional
Foo = class {}; // Re-declaration is allowed

typeof Foo; // returns "function"
typeof class {}; // returns "function"

Foo instanceof Object; // true
Foo instanceof Function; // true
class Foo {} // Throws SyntaxError (class declarations do not allow re-declaration)

```

### 类方法和属性

1.属性可以在构造函数里面进行定义与初始化，未定义的属性不能使用

注意：经过个人测试，js和python一样，都是可以动态添加属性的，

类外添加可以通过prototype

类内则直接在方法里面赋值就相当于产生了新的属性

```js
class Roob{
    age=10;
    constructor(age){
        this.name="jojo";
        this.age=age;
    }
    test(){
        this.ss=10;
    }
}

let aa=new Roob(100);
//在运行test()函数之前，aa对象并不包括ss属性，运行完之后就有了
```

2.方法直接写名字就行

```js
class Runoob {
  constructor(name, year) {
    this.name = name;
    this.year = year;
  }
  age(x) {
    return x - this.year;
  }
}
 
let date = new Date();
let year = date.getFullYear();
 
let runoob = new Runoob("菜鸟教程", 2020);
document.getElementById("demo").innerHTML=
"菜鸟教程 " + runoob.age(year) + " 岁了。";
```

### 静态方法

在实例化对象之前可以通过 **类名.方法名** 调用静态方法。

静态属性不能在类的实例上直接访问，只能是类名。

### 权限

js其实**没有**权限管理，都是在**模拟**权限行为

属性默认都是public权限，私有可以通过闭包或者#实现

```js
class ObjectCreator {
    #meaningOfLife;
    
    constructor(name) {
        this.#meaningOfLife = 42;
    }
    returnMeaningOfLife() {
        return this.#meaningOfLife;
    }
    
    #returnAMessage() {
        return "You will do great things in life";
    }
}

const myObject = new ObjectCreator("Parwinder");
console.log(myObject.returnMeaningOfLife()); // 42
console.log(myObject["#meaningOfLife"]); // undefined
console.log(myObject.#meaningOfLife); // SyntaxError     //就是无法访问
console.log(myObject.#returnAMessage); // SyntaxError

```

`#`使用限制

- 类中所有声明的私有标识符都必须是唯一的，并且命名空间在静态属性和实例属性之间是共享的。唯一的例外是：两个声明定义了 getter-setter 对。
- 私有描述符不能是 `#constructor`。

私有字段在基类中的构造函数运行之前添加，或者在子类中调用 [`super()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super) 之后立即添加

```javascript
class ClassWithPrivateField {
  #privateField;

  constructor() {
    this.#privateField = 42;
  }
}

class Subclass extends ClassWithPrivateField {
  #subPrivateField;

  constructor() {
    super();
    this.#subPrivateField = 23;
  }
}
new Subclass(); // 在一些开发工具中会显示：Subclass {#privateField: 42, #subPrivateField: 23}
//基类的 #privateField 是 ClassWithPrivateField 私有的，不能从派生的 Subclass 类中访问。
```



### 继承

类继承使用 extends 关键字。

**super()** 方法用于调用父类的构造函数

```js
class Site {
  constructor(name) {
    this.sitename = name;
  }
  present() {
    return '我喜欢' + this.sitename;
  }
}
class Runoob extends Site {
  constructor(name, age) {
    super(name);
    this.age = age;
  }
  show() {
    return this.present() + ', 它创建了 ' + this.age + ' 年。';
  }
}
let noob = new Runoob("菜鸟教程", 5);
document.getElementById("demo").innerHTML = noob.show();
```



### getter 和 setter

类中我们可以使用 getter 和 setter 来获取和设置值，getter 和 setter 都需要在严格模式下执行。

类中添加 getter 和 setter 使用的是 get 和 set 关键字。

注意：

1.即使 getter 是一个方法，当你想获取属性值时也**不要使用括号**。

类比python的attribute与property

```python
class Foo():
 def __init__(self, name):
  self.__name = name

 @property
 def name(self):
  return self.__name

foo = Foo('I do not want to be changed')
print('foo.name = ', foo.name)#一样地，无需括号，相当于类的属性
foo.name = 'Luckily, I really can not be changed'
```

2.getter/setter 方法的名称不能与属性的名称相同，在本例中属名为 sitename。

```js
class Runoob {
  constructor(name) {
    this._sitename = name;
  }
  set sitename(x) {
    this._sitename = x;
  }
  get sitename() {
    return this._sitename;
  }
}
 
let noob = new Runoob("菜鸟教程");
noob.sitename = "RUNOOB";
document.getElementById("demo").innerHTML = noob.sitename;//无需括号
```

### 销毁new出来的对象

没发现有API可以清除，不过可以通过**obj=null**来解除对该对象在执行环境中的引用

在JS里面如果一个对象不被引用，那么这个对象就会被GC回收；

**在JS里面存在两种作用域：全局作用域和函数作用域；**

- **全局变量声明之后**，它的生命周期会一直存在，直到全局作用域被销毁，例如浏览器退出、系统关闭等。new出来的对象如果是存在与全局作用域下，只有等全局作用域被销毁，对象才能被销毁。
- **函数声明之后**，等函数被调用了，系统会创建一个执行上下文，开辟一个新的内存区去运行函数，当函数执行完毕之后该区域会被回收，new出来的对象处于函数作用域内，对象会随着函数执行完毕，而被回收内存，销毁。
- 函数作用域里面new出来的对象，被外部变量所引用了（出现闭包时候），只有等外部变量不在引用函数作用域内的new出来的对象变量（即外部变量不在使用），new出来的对象会被销毁

### 类和函数

`class`和`function`都可以作为构造函数，通过`new`操作符来实例化。

```js
function Person(name) {
    this.name = name;
}

const usr = new Person('Jack');
console.log(usr); // Person { name: 'Jack' }

```

#### 区别

`class`构造函数与`function`构造函数的主要区别为，调用`class`构造函数必须使用`new`操作符。而普通`function`构造函数如果不使用`new`调用，那么会以全局的`this`（在浏览器中是`window`）作为内部对象。

```js
//普通function构造函数把window作为this来创建实例：
function Person() {}
const p = Person();
//调用class构造函数时如果忘了使用new则会抛出错误：
class Animal {}
const a = Animal();
// TypeError: Class constructor Animal cannot be invoked without 'new'

```

参考：[JavaScript class和function的区别_javascript 类和函数哪个-CSDN博客](https://blog.csdn.net/Jack_lzx/article/details/121098261)



## 原型prototype

所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法。

JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

`Date` 对象, `Array` 对象, 以及 `Person` 对象从 `Object.prototype` 继承。

### 添加属性和方法

有的时候我们想要在所有已经存在的对象添加新的属性或方法。

另外，有时候我们想要在对象的构造函数中添加属性或方法。

使用 prototype 属性就可以给对象的构造函数添加新的属性：

```js
function Person(first, last, age, eyecolor) {
  this.firstName = first;
  this.lastName = last;
  this.age = age;
  this.eyeColor = eyecolor;
}
Person.prototype.nationality = "English";//执行完之后Person就具有nationality属性

var myFather = new Person("John", "Doe", 50, "blue");
document.getElementById("demo").innerHTML =
"我父亲的国籍是 " + myFather.nationality; 
//注意，这些普通的属性是通过对象访问的
```



## 变量提升、函数提升

注意：类没有提升，必须先定义再使用

变量提升：

var,详细情况参见变量章节

函数提升：

函数提升是整个代码块提升到它所在的作用域的最开始执行

```javascript
console.log(bar);
function bar () {
  console.log(1);
}
//打印结果：ƒ bar () {
//  console.log(1);
//}
//相当于执行：
function bar () {
  console.log(1);
}
console.log(bar);
```



## JavaScript向页面输出内容的四种方法

1.使用window.alert()输出警告框
2.使用document.write()方法将内容写到html文档中，相当于添加在原有html代码中添加一串html代码。而如果在文档加载后使用（如使用函数），会覆盖整个文档。
3.使用innerHTML写入到HTML元素
4.使用console.log()写入到浏览器的控制台



获取页面元素 通过id  getElementById()

## 查找元素

有三种方法来做这件事：

- 通过 id 找到 HTML 元素

```js
var x=document.getElementById("intro");
```

- 通过标签名找到 HTML 元素

```js
var x=document.getElementById("main");
var y=x.getElementsByTagName("p");
```

- 通过类名找到 HTML 元素

```js
var x=document.getElementsByClassName("intro");
```

## 改变 HTML 属性

如需改变 HTML 元素的属性，请使用这个语法：

```js
document.getElementById(id).attribute=新属性值
```

比如：

```js
<!DOCTYPE html><html>
<body>
<img id="image" src="smiley.gif">
<script>
document.getElementById("image").src="landscape.jpg";
</script>
</body>
</html>
```

改变CSS样式

```js
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>菜鸟教程(runoob.com)</title>
</head>
<body>
 
<p id="p1">Hello World!</p>
<p id="p2">Hello World!</p>
<script>
document.getElementById("p2").style.color="blue";
document.getElementById("p2").style.fontFamily="Arial";
document.getElementById("p2").style.fontSize="larger";
</script>
<p>以上段落通过脚本修改。</p>
 
</body>
</html>
```

### 修改页面元素

插入insertBefore()

删除remove()

替换replaceChild()

参考：

[JavaScript HTML DOM 元素 (节点) | 菜鸟教程 (runoob.com)](https://www.runoob.com/js/js-htmldom-elements.html)



## HTML事件、事件属性

常见事件属性

onclick

onchange 事件常结合对输入字段的验证来使用。

onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。首先当点击鼠标按钮时，会触发 onmousedown 事件，当释放鼠标按钮时，会触发 onmouseup 事件，最后，当完成鼠标点击时，会触发 onclick 事件。

### 监听事件

```js
element.addEventListener(event, function, useCapture);
```

第一个参数是事件的类型 (如 "click" 或 "mousedown").（注意：没有“on”前缀）

第二个参数是事件触发后调用的函数。

第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。

例如：

```js
element.addEventListener("click", function(){ alert("Hello World!"); });
```

可以向同个元素添加不同类型的事件：

```js
element.addEventListener("mouseover", myFunction);element.addEventListener("click", mySecondFunction);element.addEventListener("mouseout", myThirdFunction);
```

当传递参数值时，使用"匿名函数"调用带参数的函数：

```js
element.addEventListener("click", function(){ myFunction(p1, p2); });
```

另外：

冒泡与捕获。

事件传递定义了元素事件触发的顺序。 如果你将 <p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 "click" 事件先被触发呢？

在 *冒泡* 中，**内部**元素的事件会先被触发，然后再触发外部元素，即： <p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件。

在 *捕获* 中，**外部**元素的事件会先被触发，然后才会触发内部元素的事件，即： <div> 元素的点击事件先触发 ，然后再触发 <p> 元素的点击事件。

## BOM

浏览器对象模型（**B**rowser **O**bject **M**odel (BOM)）

### Window 对象

所有浏览器都支持 window 对象。它表示浏览器窗口。

所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。

全局变量是 window 对象的属性。

全局函数是 window 对象的方法。

甚至 HTML DOM 的 document 也是 window 对象的属性之一

- window.open() - 打开新窗口
- window.close() - 关闭当前窗口
- window.moveTo() - 移动当前窗口
- window.resizeTo() - 调整当前窗口的尺寸

### Window Screen

**window.screen**对象在编写时可以不使用 window 这个前缀。

一些属性：

- screen.availWidth - 可用的屏幕宽度
- screen.availHeight - 可用的屏幕高度

### Window Location

**window.location** 对象在编写时可不使用 window 这个前缀。 一些例子：

一些实例:

- location.hostname 返回 web 主机的域名
- location.pathname 返回当前页面的路径和文件名
- location.port 返回 web 主机的端口 （80 或 443）
- location.protocol 返回所使用的 web 协议（http: 或 https:）

### Window History

**window.history**对象在编写时可不使用 window 这个前缀。

为了保护用户隐私，对 JavaScript 访问该对象的方法做出了限制。

一些方法：

- history.back() - 与在浏览器点击后退按钮相同
- history.forward() - 与在浏览器中点击向前按钮相同

### 弹窗

警告框：

```js
window.alert("sometext");
```

确认框：

```js
var r=confirm("按下按钮");//获取弹窗返回值
if (r==true)
{
    x="你按下了\"确定\"按钮!";
}
else
{
    x="你按下了\"取消\"按钮!";
}
```

提示框：

```js
var person=prompt("请输入你的名字","Harry Potter");
if (person!=null && person!="")
{
    x="你好 " + person + "! 今天感觉如何?";
    document.getElementById("demo").innerHTML=x;
}
```

## cookie

Cookie 是一些数据, 存储于你电脑上的文本文件中。

当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。

Cookie 的作用就是用于解决 "如何记录客户端的用户信息":

- 当用户访问 web 页面时，他的名字可以记录在 cookie 中。
- 在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。

使用 **document.cookie** 属性来创建 、读取、及删除 cookie。

使用`javascript:alert(document.cookie)` 可查看当前页面cookie

示例：

```javascript
function setCookie(cname,cvalue,exdays){
    var d = new Date();
    d.setTime(d.getTime()+(exdays*24*60*60*1000));
    var expires = "expires="+d.toGMTString();
    document.cookie = cname+"="+cvalue+"; "+expires;
}
function getCookie(cname){
    var name = cname + "=";
    var ca = document.cookie.split(';');
    for(var i=0; i<ca.length; i++) {
        var c = ca[i].trim();
        if (c.indexOf(name)==0) { return c.substring(name.length,c.length); }
    }
    return "";
}
function checkCookie(){
    var user=getCookie("username");
    if (user!=""){
        alert("欢迎 " + user + " 再次访问");
    }
    else {
        user = prompt("请输入你的名字:","");
          if (user!="" && user!=null){
            setCookie("username",user,30);
        }
    }
}
```

[javascript - 常用的本地存储——cookie篇 - 前端之路 - SegmentFault 思否](https://segmentfault.com/a/1190000004743454)

## TypeScript

TypeScript 是一种给 JavaScript 添加特性的语言扩展。增加的功能包括：

- 类型批注和编译时类型检查
- 类型推断
- 类型擦除
- 接口
- 枚举
- Mixin
- **泛型编程**
- 名字空间
- 元组
- Await

![](C:\Users\leo\Desktop\js笔记\ts-2020-11-26-2.png)



## vue框架

### 应用



### 文本插值

`{{msg}}`表示该变量的值，双大括号标签会被替换为`msg` 属性的值。同时每次 `msg` 属性更改时它也会同步更新。

### 指令

指令是带有 `v-` 前缀的特殊 attribute。

`v-bind` 、 `v-html`。 `v-for`、`v-on` 、 `v-slot`。

一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 [`v-if`](https://cn.vuejs.org/api/built-in-directives.html#v-if) 为例：

```vue
<p v-if="seen">Now you see me</p>
```

这里，`v-if` 指令会基于表达式 `seen` 的值的真假来移除/插入该 `<p>` 元素。



 `v-on` 指令，它将监听 DOM 事件：

```vue
<a v-on:click="doSomething"> ... </a>

<!-- 简写 -->
<a @click="doSomething"> ... </a>
```



### 响应式基础

 [`ref()`](https://cn.vuejs.org/api/reactivity-core.html#ref) 函数声明响应式状态：

```js
import { ref } from 'vue'

const count = ref(0)
console.log(count) // { value: 0 }
console.log(count.value) // 0
```

`ref()` 接收参数，并将其包裹在一个带有 `.value` 属性的 ref 对象中返回

当你在模板中使用了一个 ref，然后改变了这个 ref 的值时，Vue 会自动检测到这个变化，并且相应地更新 DOM。这是通过一个基于依赖追踪的响应式系统实现的。当一个组件首次渲染时，Vue 会**追踪**在渲染过程中使用的每一个 ref。然后，当一个 ref 被修改时，它会**触发**追踪它的组件的一次重新渲染。在标准的 JavaScript 中，检测普通变量的访问或修改是行不通的。



与将内部值包装在特殊对象中的 ref 不同，`reactive()` 将使对象本身具有响应性：

```vue
import { reactive } from 'vue'
const state = reactive({ count: 0 })
//
<button @click="state.count++">
  {{ state.count }}
</button>
```



### 计算属性

**计算属性**描述依赖响应式状态的复杂逻辑

```vue
<script setup>
import { reactive, computed } from 'vue'

const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery'
  ]
})

// 一个计算属性 ref
const publishedBooksMessage = computed(() => {
  return author.books.length > 0 ? 'Yes' : 'No'
})
</script>

<template>
  <p>Has published books:</p>
  <span>{{ publishedBooksMessage }}</span>
</template>
```

1.`computed()` 方法期望接收一个 [getter 函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get#description)，返回值为一个**计算属性 ref**。

和其他一般的 ref 类似，你可以通过 `publishedBooksMessage.value` 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 `.value`。

2.Vue 的计算属性会自动追踪响应式依赖。

它会检测到 `publishedBooksMessage` 依赖于 `author.books`，所以当 `author.books` 改变时，任何依赖于 `publishedBooksMessage` 的绑定都会同时更新。

3.若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于**计算属性值会基于其响应式依赖被缓存**。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 `author.books` 不改变，无论多少次访问 `publishedBooksMessage` 都会立即返回先前的计算结果，而不用重复执行 getter 函数。

```vue
<p>{{ calculateBooksMessage() }}</p>//使用函数则不会有缓存机制，每次都会计算

// 组件中
function calculateBooksMessage() {
  return author.books.length > 0 ? 'Yes' : 'No'
}
```



**计算属性默认是只读的**。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：

```js
<script setup>
import { ref, computed } from 'vue'

const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  // getter
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})
</script>
```

### 导出

一个模块只能有一个默认输出，所以`export default`只能使用一次

因此导入该函数时无需花括号，

```js
//functest.js
export default function func(){
    //
}
import func from "functest"

//第二组
export function func(){
    //
}
import {func} from "functest"
```

`export default`只能导出一个默认模块，这个模块可以匿名，例如：

```js
export default {
    a: 'hello',
    b: 'world'     
}
```

```js
import obj from 'demo1'
```

引入的时候可以给这个模块取任意名字，例如 "obj"，且不需要用大括号括起来。





## npm

npm install 是直接在执行指令的地方安装依赖包

所以如果不是全局的安装，必须要在项目目录下安装项目才能找到
